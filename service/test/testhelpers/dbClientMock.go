// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package testhelpers

import (
	"context"
	"github.com/cello-proj/cello/internal/types"
	"github.com/cello-proj/cello/service/internal/db"
	"sync"
)

// Ensure, that DBClientMock does implement db.Client.
// If this is not the case, regenerate this file with moq.
var _ db.Client = &DBClientMock{}

// DBClientMock is a mock implementation of db.Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked db.Client
//		mockedClient := &DBClientMock{
//			CreateIfMissingTargetEntryFunc: func(ctx context.Context, project string, target types.Target) error {
//				panic("mock out the CreateIfMissingTargetEntry method")
//			},
//			CreateProjectEntryFunc: func(ctx context.Context, pe db.ProjectEntry) error {
//				panic("mock out the CreateProjectEntry method")
//			},
//			CreateTargetEntryFunc: func(ctx context.Context, project string, target types.Target) error {
//				panic("mock out the CreateTargetEntry method")
//			},
//			CreateTokenEntryFunc: func(ctx context.Context, token types.Token) error {
//				panic("mock out the CreateTokenEntry method")
//			},
//			DeleteProjectEntryFunc: func(ctx context.Context, project string) error {
//				panic("mock out the DeleteProjectEntry method")
//			},
//			DeleteTargetEntryFunc: func(ctx context.Context, project string, targetName string) error {
//				panic("mock out the DeleteTargetEntry method")
//			},
//			DeleteTokenEntryFunc: func(ctx context.Context, token string) error {
//				panic("mock out the DeleteTokenEntry method")
//			},
//			HealthFunc: func(ctx context.Context) error {
//				panic("mock out the Health method")
//			},
//			ListTargetEntriesFunc: func(ctx context.Context, project string) ([]db.TargetEntry, error) {
//				panic("mock out the ListTargetEntries method")
//			},
//			ListTokenEntriesFunc: func(ctx context.Context, project string) ([]db.TokenEntry, error) {
//				panic("mock out the ListTokenEntries method")
//			},
//			ReadProjectEntryFunc: func(ctx context.Context, project string) (db.ProjectEntry, error) {
//				panic("mock out the ReadProjectEntry method")
//			},
//			ReadTargetEntryFunc: func(ctx context.Context, project string, targetName string) (db.TargetEntry, error) {
//				panic("mock out the ReadTargetEntry method")
//			},
//			ReadTokenEntryFunc: func(ctx context.Context, token string) (db.TokenEntry, error) {
//				panic("mock out the ReadTokenEntry method")
//			},
//			UpdateTargetEntryFunc: func(ctx context.Context, project string, target types.Target) error {
//				panic("mock out the UpdateTargetEntry method")
//			},
//			UpsertTargetEntryFunc: func(ctx context.Context, project string, target types.Target) error {
//				panic("mock out the UpsertTargetEntry method")
//			},
//		}
//
//		// use mockedClient in code that requires db.Client
//		// and then make assertions.
//
//	}
type DBClientMock struct {
	// CreateIfMissingTargetEntryFunc mocks the CreateIfMissingTargetEntry method.
	CreateIfMissingTargetEntryFunc func(ctx context.Context, project string, target types.Target) error

	// CreateProjectEntryFunc mocks the CreateProjectEntry method.
	CreateProjectEntryFunc func(ctx context.Context, pe db.ProjectEntry) error

	// CreateTargetEntryFunc mocks the CreateTargetEntry method.
	CreateTargetEntryFunc func(ctx context.Context, project string, target types.Target) error

	// CreateTokenEntryFunc mocks the CreateTokenEntry method.
	CreateTokenEntryFunc func(ctx context.Context, token types.Token) error

	// DeleteProjectEntryFunc mocks the DeleteProjectEntry method.
	DeleteProjectEntryFunc func(ctx context.Context, project string) error

	// DeleteTargetEntryFunc mocks the DeleteTargetEntry method.
	DeleteTargetEntryFunc func(ctx context.Context, project string, targetName string) error

	// DeleteTokenEntryFunc mocks the DeleteTokenEntry method.
	DeleteTokenEntryFunc func(ctx context.Context, token string) error

	// HealthFunc mocks the Health method.
	HealthFunc func(ctx context.Context) error

	// ListTargetEntriesFunc mocks the ListTargetEntries method.
	ListTargetEntriesFunc func(ctx context.Context, project string) ([]db.TargetEntry, error)

	// ListTokenEntriesFunc mocks the ListTokenEntries method.
	ListTokenEntriesFunc func(ctx context.Context, project string) ([]db.TokenEntry, error)

	// ReadProjectEntryFunc mocks the ReadProjectEntry method.
	ReadProjectEntryFunc func(ctx context.Context, project string) (db.ProjectEntry, error)

	// ReadTargetEntryFunc mocks the ReadTargetEntry method.
	ReadTargetEntryFunc func(ctx context.Context, project string, targetName string) (db.TargetEntry, error)

	// ReadTokenEntryFunc mocks the ReadTokenEntry method.
	ReadTokenEntryFunc func(ctx context.Context, token string) (db.TokenEntry, error)

	// UpdateTargetEntryFunc mocks the UpdateTargetEntry method.
	UpdateTargetEntryFunc func(ctx context.Context, project string, target types.Target) error

	// UpsertTargetEntryFunc mocks the UpsertTargetEntry method.
	UpsertTargetEntryFunc func(ctx context.Context, project string, target types.Target) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateIfMissingTargetEntry holds details about calls to the CreateIfMissingTargetEntry method.
		CreateIfMissingTargetEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
			// Target is the target argument value.
			Target types.Target
		}
		// CreateProjectEntry holds details about calls to the CreateProjectEntry method.
		CreateProjectEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pe is the pe argument value.
			Pe db.ProjectEntry
		}
		// CreateTargetEntry holds details about calls to the CreateTargetEntry method.
		CreateTargetEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
			// Target is the target argument value.
			Target types.Target
		}
		// CreateTokenEntry holds details about calls to the CreateTokenEntry method.
		CreateTokenEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token types.Token
		}
		// DeleteProjectEntry holds details about calls to the DeleteProjectEntry method.
		DeleteProjectEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
		}
		// DeleteTargetEntry holds details about calls to the DeleteTargetEntry method.
		DeleteTargetEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
			// TargetName is the targetName argument value.
			TargetName string
		}
		// DeleteTokenEntry holds details about calls to the DeleteTokenEntry method.
		DeleteTokenEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// Health holds details about calls to the Health method.
		Health []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListTargetEntries holds details about calls to the ListTargetEntries method.
		ListTargetEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
		}
		// ListTokenEntries holds details about calls to the ListTokenEntries method.
		ListTokenEntries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
		}
		// ReadProjectEntry holds details about calls to the ReadProjectEntry method.
		ReadProjectEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
		}
		// ReadTargetEntry holds details about calls to the ReadTargetEntry method.
		ReadTargetEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
			// TargetName is the targetName argument value.
			TargetName string
		}
		// ReadTokenEntry holds details about calls to the ReadTokenEntry method.
		ReadTokenEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// UpdateTargetEntry holds details about calls to the UpdateTargetEntry method.
		UpdateTargetEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
			// Target is the target argument value.
			Target types.Target
		}
		// UpsertTargetEntry holds details about calls to the UpsertTargetEntry method.
		UpsertTargetEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Project is the project argument value.
			Project string
			// Target is the target argument value.
			Target types.Target
		}
	}
	lockCreateIfMissingTargetEntry sync.RWMutex
	lockCreateProjectEntry         sync.RWMutex
	lockCreateTargetEntry          sync.RWMutex
	lockCreateTokenEntry           sync.RWMutex
	lockDeleteProjectEntry         sync.RWMutex
	lockDeleteTargetEntry          sync.RWMutex
	lockDeleteTokenEntry           sync.RWMutex
	lockHealth                     sync.RWMutex
	lockListTargetEntries          sync.RWMutex
	lockListTokenEntries           sync.RWMutex
	lockReadProjectEntry           sync.RWMutex
	lockReadTargetEntry            sync.RWMutex
	lockReadTokenEntry             sync.RWMutex
	lockUpdateTargetEntry          sync.RWMutex
	lockUpsertTargetEntry          sync.RWMutex
}

// CreateIfMissingTargetEntry calls CreateIfMissingTargetEntryFunc.
func (mock *DBClientMock) CreateIfMissingTargetEntry(ctx context.Context, project string, target types.Target) error {
	if mock.CreateIfMissingTargetEntryFunc == nil {
		panic("DBClientMock.CreateIfMissingTargetEntryFunc: method is nil but Client.CreateIfMissingTargetEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Project string
		Target  types.Target
	}{
		Ctx:     ctx,
		Project: project,
		Target:  target,
	}
	mock.lockCreateIfMissingTargetEntry.Lock()
	mock.calls.CreateIfMissingTargetEntry = append(mock.calls.CreateIfMissingTargetEntry, callInfo)
	mock.lockCreateIfMissingTargetEntry.Unlock()
	return mock.CreateIfMissingTargetEntryFunc(ctx, project, target)
}

// CreateIfMissingTargetEntryCalls gets all the calls that were made to CreateIfMissingTargetEntry.
// Check the length with:
//
//	len(mockedClient.CreateIfMissingTargetEntryCalls())
func (mock *DBClientMock) CreateIfMissingTargetEntryCalls() []struct {
	Ctx     context.Context
	Project string
	Target  types.Target
} {
	var calls []struct {
		Ctx     context.Context
		Project string
		Target  types.Target
	}
	mock.lockCreateIfMissingTargetEntry.RLock()
	calls = mock.calls.CreateIfMissingTargetEntry
	mock.lockCreateIfMissingTargetEntry.RUnlock()
	return calls
}

// CreateProjectEntry calls CreateProjectEntryFunc.
func (mock *DBClientMock) CreateProjectEntry(ctx context.Context, pe db.ProjectEntry) error {
	if mock.CreateProjectEntryFunc == nil {
		panic("DBClientMock.CreateProjectEntryFunc: method is nil but Client.CreateProjectEntry was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pe  db.ProjectEntry
	}{
		Ctx: ctx,
		Pe:  pe,
	}
	mock.lockCreateProjectEntry.Lock()
	mock.calls.CreateProjectEntry = append(mock.calls.CreateProjectEntry, callInfo)
	mock.lockCreateProjectEntry.Unlock()
	return mock.CreateProjectEntryFunc(ctx, pe)
}

// CreateProjectEntryCalls gets all the calls that were made to CreateProjectEntry.
// Check the length with:
//
//	len(mockedClient.CreateProjectEntryCalls())
func (mock *DBClientMock) CreateProjectEntryCalls() []struct {
	Ctx context.Context
	Pe  db.ProjectEntry
} {
	var calls []struct {
		Ctx context.Context
		Pe  db.ProjectEntry
	}
	mock.lockCreateProjectEntry.RLock()
	calls = mock.calls.CreateProjectEntry
	mock.lockCreateProjectEntry.RUnlock()
	return calls
}

// CreateTargetEntry calls CreateTargetEntryFunc.
func (mock *DBClientMock) CreateTargetEntry(ctx context.Context, project string, target types.Target) error {
	if mock.CreateTargetEntryFunc == nil {
		panic("DBClientMock.CreateTargetEntryFunc: method is nil but Client.CreateTargetEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Project string
		Target  types.Target
	}{
		Ctx:     ctx,
		Project: project,
		Target:  target,
	}
	mock.lockCreateTargetEntry.Lock()
	mock.calls.CreateTargetEntry = append(mock.calls.CreateTargetEntry, callInfo)
	mock.lockCreateTargetEntry.Unlock()
	return mock.CreateTargetEntryFunc(ctx, project, target)
}

// CreateTargetEntryCalls gets all the calls that were made to CreateTargetEntry.
// Check the length with:
//
//	len(mockedClient.CreateTargetEntryCalls())
func (mock *DBClientMock) CreateTargetEntryCalls() []struct {
	Ctx     context.Context
	Project string
	Target  types.Target
} {
	var calls []struct {
		Ctx     context.Context
		Project string
		Target  types.Target
	}
	mock.lockCreateTargetEntry.RLock()
	calls = mock.calls.CreateTargetEntry
	mock.lockCreateTargetEntry.RUnlock()
	return calls
}

// CreateTokenEntry calls CreateTokenEntryFunc.
func (mock *DBClientMock) CreateTokenEntry(ctx context.Context, token types.Token) error {
	if mock.CreateTokenEntryFunc == nil {
		panic("DBClientMock.CreateTokenEntryFunc: method is nil but Client.CreateTokenEntry was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token types.Token
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockCreateTokenEntry.Lock()
	mock.calls.CreateTokenEntry = append(mock.calls.CreateTokenEntry, callInfo)
	mock.lockCreateTokenEntry.Unlock()
	return mock.CreateTokenEntryFunc(ctx, token)
}

// CreateTokenEntryCalls gets all the calls that were made to CreateTokenEntry.
// Check the length with:
//
//	len(mockedClient.CreateTokenEntryCalls())
func (mock *DBClientMock) CreateTokenEntryCalls() []struct {
	Ctx   context.Context
	Token types.Token
} {
	var calls []struct {
		Ctx   context.Context
		Token types.Token
	}
	mock.lockCreateTokenEntry.RLock()
	calls = mock.calls.CreateTokenEntry
	mock.lockCreateTokenEntry.RUnlock()
	return calls
}

// DeleteProjectEntry calls DeleteProjectEntryFunc.
func (mock *DBClientMock) DeleteProjectEntry(ctx context.Context, project string) error {
	if mock.DeleteProjectEntryFunc == nil {
		panic("DBClientMock.DeleteProjectEntryFunc: method is nil but Client.DeleteProjectEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Project string
	}{
		Ctx:     ctx,
		Project: project,
	}
	mock.lockDeleteProjectEntry.Lock()
	mock.calls.DeleteProjectEntry = append(mock.calls.DeleteProjectEntry, callInfo)
	mock.lockDeleteProjectEntry.Unlock()
	return mock.DeleteProjectEntryFunc(ctx, project)
}

// DeleteProjectEntryCalls gets all the calls that were made to DeleteProjectEntry.
// Check the length with:
//
//	len(mockedClient.DeleteProjectEntryCalls())
func (mock *DBClientMock) DeleteProjectEntryCalls() []struct {
	Ctx     context.Context
	Project string
} {
	var calls []struct {
		Ctx     context.Context
		Project string
	}
	mock.lockDeleteProjectEntry.RLock()
	calls = mock.calls.DeleteProjectEntry
	mock.lockDeleteProjectEntry.RUnlock()
	return calls
}

// DeleteTargetEntry calls DeleteTargetEntryFunc.
func (mock *DBClientMock) DeleteTargetEntry(ctx context.Context, project string, targetName string) error {
	if mock.DeleteTargetEntryFunc == nil {
		panic("DBClientMock.DeleteTargetEntryFunc: method is nil but Client.DeleteTargetEntry was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Project    string
		TargetName string
	}{
		Ctx:        ctx,
		Project:    project,
		TargetName: targetName,
	}
	mock.lockDeleteTargetEntry.Lock()
	mock.calls.DeleteTargetEntry = append(mock.calls.DeleteTargetEntry, callInfo)
	mock.lockDeleteTargetEntry.Unlock()
	return mock.DeleteTargetEntryFunc(ctx, project, targetName)
}

// DeleteTargetEntryCalls gets all the calls that were made to DeleteTargetEntry.
// Check the length with:
//
//	len(mockedClient.DeleteTargetEntryCalls())
func (mock *DBClientMock) DeleteTargetEntryCalls() []struct {
	Ctx        context.Context
	Project    string
	TargetName string
} {
	var calls []struct {
		Ctx        context.Context
		Project    string
		TargetName string
	}
	mock.lockDeleteTargetEntry.RLock()
	calls = mock.calls.DeleteTargetEntry
	mock.lockDeleteTargetEntry.RUnlock()
	return calls
}

// DeleteTokenEntry calls DeleteTokenEntryFunc.
func (mock *DBClientMock) DeleteTokenEntry(ctx context.Context, token string) error {
	if mock.DeleteTokenEntryFunc == nil {
		panic("DBClientMock.DeleteTokenEntryFunc: method is nil but Client.DeleteTokenEntry was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockDeleteTokenEntry.Lock()
	mock.calls.DeleteTokenEntry = append(mock.calls.DeleteTokenEntry, callInfo)
	mock.lockDeleteTokenEntry.Unlock()
	return mock.DeleteTokenEntryFunc(ctx, token)
}

// DeleteTokenEntryCalls gets all the calls that were made to DeleteTokenEntry.
// Check the length with:
//
//	len(mockedClient.DeleteTokenEntryCalls())
func (mock *DBClientMock) DeleteTokenEntryCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockDeleteTokenEntry.RLock()
	calls = mock.calls.DeleteTokenEntry
	mock.lockDeleteTokenEntry.RUnlock()
	return calls
}

// Health calls HealthFunc.
func (mock *DBClientMock) Health(ctx context.Context) error {
	if mock.HealthFunc == nil {
		panic("DBClientMock.HealthFunc: method is nil but Client.Health was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHealth.Lock()
	mock.calls.Health = append(mock.calls.Health, callInfo)
	mock.lockHealth.Unlock()
	return mock.HealthFunc(ctx)
}

// HealthCalls gets all the calls that were made to Health.
// Check the length with:
//
//	len(mockedClient.HealthCalls())
func (mock *DBClientMock) HealthCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHealth.RLock()
	calls = mock.calls.Health
	mock.lockHealth.RUnlock()
	return calls
}

// ListTargetEntries calls ListTargetEntriesFunc.
func (mock *DBClientMock) ListTargetEntries(ctx context.Context, project string) ([]db.TargetEntry, error) {
	if mock.ListTargetEntriesFunc == nil {
		panic("DBClientMock.ListTargetEntriesFunc: method is nil but Client.ListTargetEntries was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Project string
	}{
		Ctx:     ctx,
		Project: project,
	}
	mock.lockListTargetEntries.Lock()
	mock.calls.ListTargetEntries = append(mock.calls.ListTargetEntries, callInfo)
	mock.lockListTargetEntries.Unlock()
	return mock.ListTargetEntriesFunc(ctx, project)
}

// ListTargetEntriesCalls gets all the calls that were made to ListTargetEntries.
// Check the length with:
//
//	len(mockedClient.ListTargetEntriesCalls())
func (mock *DBClientMock) ListTargetEntriesCalls() []struct {
	Ctx     context.Context
	Project string
} {
	var calls []struct {
		Ctx     context.Context
		Project string
	}
	mock.lockListTargetEntries.RLock()
	calls = mock.calls.ListTargetEntries
	mock.lockListTargetEntries.RUnlock()
	return calls
}

// ListTokenEntries calls ListTokenEntriesFunc.
func (mock *DBClientMock) ListTokenEntries(ctx context.Context, project string) ([]db.TokenEntry, error) {
	if mock.ListTokenEntriesFunc == nil {
		panic("DBClientMock.ListTokenEntriesFunc: method is nil but Client.ListTokenEntries was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Project string
	}{
		Ctx:     ctx,
		Project: project,
	}
	mock.lockListTokenEntries.Lock()
	mock.calls.ListTokenEntries = append(mock.calls.ListTokenEntries, callInfo)
	mock.lockListTokenEntries.Unlock()
	return mock.ListTokenEntriesFunc(ctx, project)
}

// ListTokenEntriesCalls gets all the calls that were made to ListTokenEntries.
// Check the length with:
//
//	len(mockedClient.ListTokenEntriesCalls())
func (mock *DBClientMock) ListTokenEntriesCalls() []struct {
	Ctx     context.Context
	Project string
} {
	var calls []struct {
		Ctx     context.Context
		Project string
	}
	mock.lockListTokenEntries.RLock()
	calls = mock.calls.ListTokenEntries
	mock.lockListTokenEntries.RUnlock()
	return calls
}

// ReadProjectEntry calls ReadProjectEntryFunc.
func (mock *DBClientMock) ReadProjectEntry(ctx context.Context, project string) (db.ProjectEntry, error) {
	if mock.ReadProjectEntryFunc == nil {
		panic("DBClientMock.ReadProjectEntryFunc: method is nil but Client.ReadProjectEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Project string
	}{
		Ctx:     ctx,
		Project: project,
	}
	mock.lockReadProjectEntry.Lock()
	mock.calls.ReadProjectEntry = append(mock.calls.ReadProjectEntry, callInfo)
	mock.lockReadProjectEntry.Unlock()
	return mock.ReadProjectEntryFunc(ctx, project)
}

// ReadProjectEntryCalls gets all the calls that were made to ReadProjectEntry.
// Check the length with:
//
//	len(mockedClient.ReadProjectEntryCalls())
func (mock *DBClientMock) ReadProjectEntryCalls() []struct {
	Ctx     context.Context
	Project string
} {
	var calls []struct {
		Ctx     context.Context
		Project string
	}
	mock.lockReadProjectEntry.RLock()
	calls = mock.calls.ReadProjectEntry
	mock.lockReadProjectEntry.RUnlock()
	return calls
}

// ReadTargetEntry calls ReadTargetEntryFunc.
func (mock *DBClientMock) ReadTargetEntry(ctx context.Context, project string, targetName string) (db.TargetEntry, error) {
	if mock.ReadTargetEntryFunc == nil {
		panic("DBClientMock.ReadTargetEntryFunc: method is nil but Client.ReadTargetEntry was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Project    string
		TargetName string
	}{
		Ctx:        ctx,
		Project:    project,
		TargetName: targetName,
	}
	mock.lockReadTargetEntry.Lock()
	mock.calls.ReadTargetEntry = append(mock.calls.ReadTargetEntry, callInfo)
	mock.lockReadTargetEntry.Unlock()
	return mock.ReadTargetEntryFunc(ctx, project, targetName)
}

// ReadTargetEntryCalls gets all the calls that were made to ReadTargetEntry.
// Check the length with:
//
//	len(mockedClient.ReadTargetEntryCalls())
func (mock *DBClientMock) ReadTargetEntryCalls() []struct {
	Ctx        context.Context
	Project    string
	TargetName string
} {
	var calls []struct {
		Ctx        context.Context
		Project    string
		TargetName string
	}
	mock.lockReadTargetEntry.RLock()
	calls = mock.calls.ReadTargetEntry
	mock.lockReadTargetEntry.RUnlock()
	return calls
}

// ReadTokenEntry calls ReadTokenEntryFunc.
func (mock *DBClientMock) ReadTokenEntry(ctx context.Context, token string) (db.TokenEntry, error) {
	if mock.ReadTokenEntryFunc == nil {
		panic("DBClientMock.ReadTokenEntryFunc: method is nil but Client.ReadTokenEntry was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockReadTokenEntry.Lock()
	mock.calls.ReadTokenEntry = append(mock.calls.ReadTokenEntry, callInfo)
	mock.lockReadTokenEntry.Unlock()
	return mock.ReadTokenEntryFunc(ctx, token)
}

// ReadTokenEntryCalls gets all the calls that were made to ReadTokenEntry.
// Check the length with:
//
//	len(mockedClient.ReadTokenEntryCalls())
func (mock *DBClientMock) ReadTokenEntryCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockReadTokenEntry.RLock()
	calls = mock.calls.ReadTokenEntry
	mock.lockReadTokenEntry.RUnlock()
	return calls
}

// UpdateTargetEntry calls UpdateTargetEntryFunc.
func (mock *DBClientMock) UpdateTargetEntry(ctx context.Context, project string, target types.Target) error {
	if mock.UpdateTargetEntryFunc == nil {
		panic("DBClientMock.UpdateTargetEntryFunc: method is nil but Client.UpdateTargetEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Project string
		Target  types.Target
	}{
		Ctx:     ctx,
		Project: project,
		Target:  target,
	}
	mock.lockUpdateTargetEntry.Lock()
	mock.calls.UpdateTargetEntry = append(mock.calls.UpdateTargetEntry, callInfo)
	mock.lockUpdateTargetEntry.Unlock()
	return mock.UpdateTargetEntryFunc(ctx, project, target)
}

// UpdateTargetEntryCalls gets all the calls that were made to UpdateTargetEntry.
// Check the length with:
//
//	len(mockedClient.UpdateTargetEntryCalls())
func (mock *DBClientMock) UpdateTargetEntryCalls() []struct {
	Ctx     context.Context
	Project string
	Target  types.Target
} {
	var calls []struct {
		Ctx     context.Context
		Project string
		Target  types.Target
	}
	mock.lockUpdateTargetEntry.RLock()
	calls = mock.calls.UpdateTargetEntry
	mock.lockUpdateTargetEntry.RUnlock()
	return calls
}

// UpsertTargetEntry calls UpsertTargetEntryFunc.
func (mock *DBClientMock) UpsertTargetEntry(ctx context.Context, project string, target types.Target) error {
	if mock.UpsertTargetEntryFunc == nil {
		panic("DBClientMock.UpsertTargetEntryFunc: method is nil but Client.UpsertTargetEntry was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Project string
		Target  types.Target
	}{
		Ctx:     ctx,
		Project: project,
		Target:  target,
	}
	mock.lockUpsertTargetEntry.Lock()
	mock.calls.UpsertTargetEntry = append(mock.calls.UpsertTargetEntry, callInfo)
	mock.lockUpsertTargetEntry.Unlock()
	return mock.UpsertTargetEntryFunc(ctx, project, target)
}

// UpsertTargetEntryCalls gets all the calls that were made to UpsertTargetEntry.
// Check the length with:
//
//	len(mockedClient.UpsertTargetEntryCalls())
func (mock *DBClientMock) UpsertTargetEntryCalls() []struct {
	Ctx     context.Context
	Project string
	Target  types.Target
} {
	var calls []struct {
		Ctx     context.Context
		Project string
		Target  types.Target
	}
	mock.lockUpsertTargetEntry.RLock()
	calls = mock.calls.UpsertTargetEntry
	mock.lockUpsertTargetEntry.RUnlock()
	return calls
}
